"""Commande d'aide interactive avec menu d√©roulant."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Optional, Sequence, cast

import discord
from discord.ext import commands

from config import PREFIX
from utils import embeds


def _strip_prefix(value: str) -> str:
    """Retire le pr√©fixe configur√© de la commande fournie si pr√©sent."""

    value = value.strip()
    if not value:
        return value

    prefix_length = len(PREFIX)
    if value[:prefix_length].lower() == PREFIX.lower():
        return value[prefix_length:].strip()

    return value


def _generate_lookup_variants(value: str) -> tuple[str, ...]:
    """G√©n√®re les variantes normalis√©es permettant de retrouver une commande."""

    base = value.strip()
    if not base:
        return ()

    variants: list[str] = []

    def _add_variant(text: str) -> None:
        normalized = text.strip().lower()
        if normalized and normalized not in variants:
            variants.append(normalized)

    _add_variant(base)

    stripped = _strip_prefix(base)
    if stripped:
        _add_variant(stripped)
        parts = stripped.split()
        if parts:
            _add_variant(parts[0])
            if len(parts) > 1:
                _add_variant(" ".join(parts[:2]))

    return tuple(variants)


@dataclass(frozen=True)
class HelpCommand:
    """Repr√©sente une commande individuelle affich√©e dans le menu d'aide."""

    command: str
    description: str
    aliases: tuple[str, ...] = ()
    icon: str = "‚Ä¢"
    note: Optional[str] = None

    def format_line(self) -> str:
        """Retourne une ligne mise en forme pour un embed Discord."""

        alias_text = ""
        if self.aliases:
            formatted_aliases = ", ".join(
                f"`{alias}`" if alias.startswith(PREFIX) else f"`{PREFIX}{alias}`"
                for alias in self.aliases
            )
            alias_text = f" ¬∑ {formatted_aliases}"

        header = f"{self.icon} **{self.command}**{alias_text}"
        body_lines = [f"> {self.description}"]
        if self.note:
            body_lines.append(f"> {self.note}")

        return "\n".join([header, *body_lines])

    def iter_lookup_keys(self) -> tuple[str, ...]:
        """Retourne les cl√©s normalis√©es permettant d'identifier la commande."""

        variants = list(_generate_lookup_variants(self.command))
        for alias in self.aliases:
            alias_value = alias if alias.startswith(PREFIX) else f"{PREFIX}{alias}"
            variants.extend(_generate_lookup_variants(alias_value))

        seen: set[str] = set()
        unique_variants: list[str] = []
        for variant in variants:
            if variant not in seen:
                seen.add(variant)
                unique_variants.append(variant)

        return tuple(unique_variants)

    def matches(self, query: str) -> bool:
        """Indique si la requ√™te fournie correspond √† cette commande."""

        normalized_query = _strip_prefix(query).lower()
        if not normalized_query:
            return False

        for key in self.iter_lookup_keys():
            if normalized_query == key or key.startswith(normalized_query):
                return True

        return False


@dataclass(frozen=True)
class HelpSection:
    """Repr√©sente une section d'aide avec ses commandes associ√©es."""

    key: str
    label: str
    description: str
    commands: tuple[HelpCommand, ...]


class HelpMenuSelect(discord.ui.Select):
    """Menu d√©roulant permettant de choisir la cat√©gorie d'aide."""

    def __init__(self, help_view: "HelpMenuView") -> None:
        options = [
            discord.SelectOption(
                label="üìö Toutes les commandes",
                value="all",
                description="Affiche l'ensemble des commandes disponibles.",
            )
        ]

        for section in help_view.section_order:
            options.append(
                discord.SelectOption(
                    label=section.label,
                    value=section.key,
                    description=section.description[:100],
                )
            )

        super().__init__(
            placeholder="üåü Choisis la cat√©gorie qui t'int√©resse‚Ä¶",
            min_values=1,
            max_values=1,
            options=options,
        )

    async def callback(self, interaction: discord.Interaction) -> None:
        if self.view is None:  # pragma: no cover - defensive
            return

        help_view = cast(HelpMenuView, self.view)
        embed = help_view.get_embed(self.values[0])
        await interaction.response.edit_message(embed=embed, view=help_view)


class HelpMenuView(discord.ui.View):
    """Vue interactive contenant le menu d√©roulant des commandes."""

    def __init__(
        self,
        *,
        author: discord.abc.User,
        sections: Sequence[HelpSection],
        build_section_embed: Callable[[HelpSection], discord.Embed],
        build_all_embed: Callable[[], discord.Embed],
        timeout: float = 180,
    ) -> None:
        super().__init__(timeout=timeout)
        self.author = author
        self.section_order: tuple[HelpSection, ...] = tuple(sections)
        self.section_map = {section.key: section for section in sections}
        self._build_section_embed = build_section_embed
        self._build_all_embed = build_all_embed
        self.message: Optional[discord.Message] = None
        self.add_item(HelpMenuSelect(self))

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user and interaction.user.id == self.author.id:
            return True

        await interaction.response.send_message(
            "Seule la personne ayant demand√© l'aide peut utiliser ce menu.",
            ephemeral=True,
        )
        return False

    def get_embed(self, key: str) -> discord.Embed:
        if key == "all":
            return self._build_all_embed()

        section = self.section_map.get(key)
        if section is None:
            return self._build_all_embed()

        return self._build_section_embed(section)

    async def on_timeout(self) -> None:
        if self.message is None:
            return

        for child in self.children:
            if isinstance(child, discord.ui.Select):
                child.disabled = True

        await self.message.edit(view=self)


class Help(commands.Cog):
    """Affiche la liste compl√®te des commandes via un menu interactif."""

    FOOTER_TEXT = (
        "Besoin d'un rappel ? Utilise e!help √† tout moment. Astuce : d√©marre chaque journ√©e avec e!daily !"
    )

    def __init__(self, bot: commands.Bot) -> None:
        self.bot = bot
        self._sections: tuple[HelpSection, ...] = (
            HelpSection(
                key="getting_started",
                label="üöÄ Bien d√©marrer",
                description="Les √©tapes essentielles pour lancer ton √©conomie.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}daily",
                        "Commence chaque journ√©e en r√©cup√©rant ta r√©compense pour lancer ton √©pargne.",
                        icon="1Ô∏è‚É£",
                    ),
                    HelpCommand(
                        f"{PREFIX}openbox [≈ìuf]",
                        "Ouvre ton premier ≈ìuf et d√©bloque un compagnon g√©n√©rateur de PB.",
                        icon="2Ô∏è‚É£",
                    ),
                    HelpCommand(
                        f"{PREFIX}equip [id]",
                        "√âquipe ton meilleur pet puis r√©cup√®re tes gains avec la commande claim.",
                        icon="3Ô∏è‚É£",
                        note=f"Pense √† utiliser `{PREFIX}claim` pour ramasser tes profits.",
                    ),
                    HelpCommand(
                        f"{PREFIX}index",
                        "Suis l'avancement de ta collection et rep√®re les pets manquants.",
                        icon="4Ô∏è‚É£",
                    ),
                ),
            ),
            HelpSection(
                key="economy",
                label="üí∞ √âconomie",
                description="Toutes les commandes li√©es aux PB et mini-jeux.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}balance",
                        "Consulte ton solde actuel en un clin d'≈ìil.",
                        aliases=("bal",),
                    ),
                    HelpCommand(
                        f"{PREFIX}daily",
                        "Collecte ta r√©compense quotidienne et maintiens ta s√©rie.",
                    ),
                    HelpCommand(
                        f"{PREFIX}give @membre montant",
                        "Offre des PrissBucks √† un joueur pour soutenir sa progression.",
                    ),
                    HelpCommand(
                        f"{PREFIX}give mortis",
                        "Distribue un Huge Mortis √† tous les VIP.",
                        note="Commande r√©serv√©e au propri√©taire du bot.",
                    ),
                    HelpCommand(
                        f"{PREFIX}slots mise",
                        "Tente ta chance √† la machine √† sous et d√©croche un jackpot.",
                    ),
                    HelpCommand(
                        f"{PREFIX}mastermind",
                        "R√©sous le code secret pour remporter des PB bonus.",
                    ),
                    HelpCommand(
                        f"{PREFIX}millionairerace",
                        "Prends part √† la course millionnaire et fais exploser ta fortune.",
                    ),
                ),
            ),
            HelpSection(
                key="clans",
                label="‚öîÔ∏è Clans",
                description="Gestion des clans et des boosts communautaires.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}clan",
                        "Affiche le tableau de bord de ton clan et ses boosts actifs.",
                    ),
                    HelpCommand(
                        f"{PREFIX}clan create <nom>",
                        "Fonde un clan (25 000 PB) pour lancer ta propre alliance.",
                    ),
                    HelpCommand(
                        f"{PREFIX}clan join <nom>",
                        "Rejoins un clan existant et profite de ses avantages.",
                    ),
                    HelpCommand(
                        f"{PREFIX}clan slots",
                        "Augmente la capacit√© maximale de ton clan contre des PB.",
                    ),
                    HelpCommand(
                        f"{PREFIX}clan boost",
                        "Ach√®te un turbo PB permanent b√©n√©fique √† tous les membres.",
                    ),
                ),
            ),
            HelpSection(
                key="grades",
                label="üéñÔ∏è Grades",
                description="Progression et classements de grades.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}grade",
                        "Affiche ton profil de grade et tes objectifs en cours.",
                    ),
                    HelpCommand(
                        f"{PREFIX}gradeleaderboard",
                        "Consulte le classement des grades pour mesurer ton avanc√©e.",
                        aliases=("gradelb",),
                    ),
                ),
            ),
            HelpSection(
                key="pets",
                label="üêæ Pets",
                description="Tout pour g√©rer ton arm√©e de pets.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}openbox [≈ìuf]",
                        "Ouvre un ≈ìuf pour obtenir un nouveau pet.",
                    ),
                    HelpCommand(
                        f"{PREFIX}eggs",
                        "Consulte les zones et ≈ìufs disponibles.",
                        aliases=("zones",),
                    ),
                    HelpCommand(
                        f"{PREFIX}pets",
                        "Visualise ton inventaire actuel.",
                        aliases=("inventory",),
                    ),
                    HelpCommand(
                        f"{PREFIX}index",
                        "Parcours l'index complet et rep√®re les pets manquants.",
                        aliases=("petindex", "dex"),
                    ),
                    HelpCommand(
                        f"{PREFIX}equip [id]",
                        "√âquipe un pet pour augmenter tes gains.",
                    ),
                    HelpCommand(
                        f"{PREFIX}equipbest",
                        "√âquipe automatiquement tes pets les plus rentables.",
                        aliases=("bestpets", "autoequip"),
                    ),
                    HelpCommand(
                        f"{PREFIX}goldify",
                        "Fusionne tes pets en version or pour booster leur puissance.",
                        aliases=("gold", "fusion"),
                    ),
                    HelpCommand(
                        f"{PREFIX}claim",
                        "R√©cup√®re les PB g√©n√©r√©s par tes pets.",
                    ),
                ),
            ),
            HelpSection(
                key="stands",
                label="üè¨ Plaza",
                description="Installe ton stand et parcours la plaza.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}stand [@membre]",
                        "Affiche ton stand ou celui d'un autre joueur.",
                    ),
                    HelpCommand(
                        f"{PREFIX}stand add <prix> <pet>",
                        "Met un pet en vente sur ton stand.",
                    ),
                    HelpCommand(
                        f"{PREFIX}stand remove <id>",
                        "Retire une annonce active.",
                    ),
                    HelpCommand(
                        f"{PREFIX}stand buy <id>",
                        "Ach√®te un pet depuis un stand.",
                    ),
                    HelpCommand(
                        f"{PREFIX}stand history",
                        "Consulte l'historique de tes ventes et achats.",
                    ),
                    HelpCommand(
                        f"{PREFIX}plaza",
                        "Vue d'ensemble des stands actifs.",
                    ),
                ),
            ),
            HelpSection(
                key="leaderboards",
                label="üìä Classements",
                description="Acc√®de aux diff√©rents classements √©conomiques.",
                commands=(
                    HelpCommand(
                        f"{PREFIX}leaderboard",
                        "Classement g√©n√©ral des fortunes.",
                        aliases=("lb",),
                    ),
                    HelpCommand(
                        f"{PREFIX}rapleaderboard",
                        "Classement RAP des pets.",
                        aliases=("raplb", "rap"),
                    ),
                    HelpCommand(
                        f"{PREFIX}revenusleaderboard",
                        "Classement des revenus horaires.",
                        aliases=("revenuslb", "incomelb", "hourlylb"),
                    ),
                ),
            ),
        )

    @commands.command(name="help")
    async def help_command(self, ctx: commands.Context, *, query: Optional[str] = None) -> None:
        """Envoie un menu d√©roulant ou le d√©tail d'une commande recherch√©e."""

        if query:
            result = self._find_command(query)
            if result is not None:
                section, command = result
                embed = self._build_command_detail_embed(section, command)
                await ctx.send(embed=embed)
                return

            suggestions = self._suggest_commands(query)
            if suggestions:
                suggestion_lines = "\n".join(f"‚Ä¢ `{suggestion}`" for suggestion in suggestions)
                embed = embeds.warning_embed(
                    "Je n'ai trouv√© aucune commande correspondant √† ta recherche.\n\n"
                    f"Essaie peut-√™tre :\n{suggestion_lines}",
                    title="Commande introuvable",
                )
            else:
                embed = embeds.error_embed(
                    f"Aucune commande ne correspond √† `{query}`.",
                    title="Commande introuvable",
                )

            await ctx.send(embed=embed)
            return

        view = HelpMenuView(
            author=ctx.author,
            sections=self._sections,
            build_section_embed=self._build_section_embed,
            build_all_embed=self._build_all_embed,
        )
        embed = self._build_all_embed()
        message = await ctx.send(embed=embed, view=view)
        view.message = message

    def _build_all_embed(self) -> discord.Embed:
        embed = embeds.info_embed(
            "S√©lectionne une cat√©gorie pour filtrer les commandes ou parcoure la liste compl√®te ci-dessous.",
            title="EcoBot ‚Äî Centre d'aide",
        )

        bot_user = self.bot.user
        if bot_user is not None:
            avatar_url = bot_user.display_avatar.url
            embed.set_author(name="EcoBot", icon_url=avatar_url)
            embed.set_thumbnail(url=avatar_url)

        for section in self._sections:
            formatted_commands = "\n\n".join(command.format_line() for command in section.commands)
            embed.add_field(name=section.label, value=formatted_commands, inline=False)

        embed.set_footer(text=self.FOOTER_TEXT)
        return embed

    def _build_section_embed(self, section: HelpSection) -> discord.Embed:
        embed = embeds.info_embed(
            "\n\n".join(command.format_line() for command in section.commands),
            title=f"{section.label} ‚Äî Commandes",
        )

        bot_user = self.bot.user
        if bot_user is not None:
            avatar_url = bot_user.display_avatar.url
            embed.set_author(name=f"EcoBot ¬∑ {section.label}", icon_url=avatar_url)
            embed.set_thumbnail(url=avatar_url)

        embed.set_footer(text=self.FOOTER_TEXT)
        return embed

    def _find_command(self, query: str) -> Optional[tuple[HelpSection, HelpCommand]]:
        """Recherche une commande correspondant √† la requ√™te fournie."""

        for section in self._sections:
            for command in section.commands:
                if command.matches(query):
                    return section, command

        return None

    def _build_command_detail_embed(
        self, section: HelpSection, command: HelpCommand
    ) -> discord.Embed:
        """Construit un embed d√©taillant une commande sp√©cifique."""

        description_lines = [command.description]
        if command.note:
            description_lines.append(f"üí° {command.note}")

        embed = embeds.info_embed(
            "\n\n".join(description_lines),
            title=f"{command.command} ‚Äî Aide d√©taill√©e",
        )

        embed.add_field(name="Cat√©gorie", value=section.label, inline=False)
        embed.add_field(name="Utilisation", value=f"`{command.command}`", inline=False)

        if command.aliases:
            alias_display = ", ".join(
                f"`{alias}`" if alias.startswith(PREFIX) else f"`{PREFIX}{alias}`"
                for alias in command.aliases
            )
            embed.add_field(name="Alias", value=alias_display, inline=False)

        bot_user = self.bot.user
        if bot_user is not None:
            avatar_url = bot_user.display_avatar.url
            embed.set_author(name="EcoBot", icon_url=avatar_url)
            embed.set_thumbnail(url=avatar_url)

        embed.set_footer(text=self.FOOTER_TEXT)
        return embed

    def _suggest_commands(self, query: str, *, limit: int = 5) -> list[str]:
        """Propose des commandes proches de la requ√™te fournie."""

        normalized_query = _strip_prefix(query).lower()
        if not normalized_query:
            return []

        suggestions: list[str] = []
        seen: set[str] = set()

        for section in self._sections:
            for command in section.commands:
                if command.command in seen:
                    continue

                for key in command.iter_lookup_keys():
                    if normalized_query in key and command.command not in seen:
                        suggestions.append(command.command)
                        seen.add(command.command)
                        break

                if len(suggestions) >= limit:
                    return suggestions[:limit]

        return suggestions[:limit]


async def setup(bot: commands.Bot) -> None:
    await bot.add_cog(Help(bot))
