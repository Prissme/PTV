import discord
from discord.ext import commands
from discord import app_commands
import asyncio
import random
import logging
from datetime import datetime, timezone

from config import Colors, Emojis, OWNER_ID
from utils.embeds import create_error_embed, create_success_embed, create_info_embed

logger = logging.getLogger(__name__)

class PPCView(discord.ui.View):
    """Vue pour le jeu Pierre-Papier-Ciseaux en BO1 avec syst√®me CORRIG√â"""
    
    def __init__(self, challenger, opponent, bet_amount, db):
        super().__init__(timeout=60.0)  # 1 minute pour un BO1
        self.challenger = challenger
        self.opponent = opponent  
        self.bet_amount = bet_amount
        self.db = db
        
        # Choix des joueurs
        self.challenger_choice = None
        self.opponent_choice = None
        
        # Status du jeu
        self.game_finished = False
        
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        """V√©rifie que seuls les joueurs concern√©s peuvent interagir"""
        if interaction.user.id not in [self.challenger.id, self.opponent.id]:
            await interaction.response.send_message(
                "‚ùå Tu ne peux pas participer √† ce jeu !", ephemeral=True
            )
            return False
        return True

    @discord.ui.button(label='üóø Pierre', style=discord.ButtonStyle.secondary)
    async def pierre_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.make_choice(interaction, 'pierre', 'üóø')

    @discord.ui.button(label='üìÑ Papier', style=discord.ButtonStyle.secondary) 
    async def papier_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.make_choice(interaction, 'papier', 'üìÑ')

    @discord.ui.button(label='‚úÇÔ∏è Ciseaux', style=discord.ButtonStyle.secondary)
    async def ciseaux_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.make_choice(interaction, 'ciseaux', '‚úÇÔ∏è')

    async def make_choice(self, interaction: discord.Interaction, choice: str, emoji: str):
        """G√®re le choix d'un joueur"""
        if self.game_finished:
            await interaction.response.send_message("‚ùå Ce jeu est termin√© !", ephemeral=True)
            return

        user = interaction.user
        
        # Enregistrer le choix
        if user.id == self.challenger.id:
            if self.challenger_choice is not None:
                await interaction.response.send_message(
                    f"‚ùå Tu as d√©j√† choisi {self.challenger_choice}!", ephemeral=True
                )
                return
            self.challenger_choice = choice
        elif user.id == self.opponent.id:
            if self.opponent_choice is not None:
                await interaction.response.send_message(
                    f"‚ùå Tu as d√©j√† choisi {self.opponent_choice}!", ephemeral=True
                )
                return
            self.opponent_choice = choice

        # R√©pondre √† l'interaction imm√©diatement
        await interaction.response.send_message(
            f"‚úÖ Tu as choisi {emoji} **{choice.capitalize()}** !", ephemeral=True
        )

        # V√©rifier si les deux ont jou√©
        if self.challenger_choice and self.opponent_choice:
            await self.finish_game()

    async def finish_game(self):
        """Termine le jeu et d√©termine le gagnant avec syst√®me CORRIG√â"""
        self.game_finished = True
        
        try:
            # R√©cup√©rer les soldes AVANT les transferts
            challenger_balance_before = await self.db.get_balance(self.challenger.id)
            opponent_balance_before = await self.db.get_balance(self.opponent.id)
            
            # D√©terminer le gagnant
            winner = self.determine_winner()
            
            # Cr√©er l'embed de r√©sultat
            c_emoji = {'pierre': 'üóø', 'papier': 'üìÑ', 'ciseaux': '‚úÇÔ∏è'}[self.challenger_choice]
            o_emoji = {'pierre': 'üóø', 'papier': 'üìÑ', 'ciseaux': '‚úÇÔ∏è'}[self.opponent_choice]
            
            if winner == 'tie':
                # √âGALIT√â: Envoyer vers banque publique
                logger.info(f"PPC: √âgalit√© - Transfert de {self.bet_amount * 2} PB vers banque publique")
                
                # D√©biter les deux joueurs
                await self.db.update_balance(self.challenger.id, -self.bet_amount)
                await self.db.update_balance(self.opponent.id, -self.bet_amount)
                
                # Envoyer vers banque publique
                public_bank_cog = self.db.bot.get_cog('PublicBank') if hasattr(self.db, 'bot') else None
                if not public_bank_cog:
                    # Chercher dans les cogs du bot
                    for cog_name, cog in self.db.bot.cogs.items() if hasattr(self.db, 'bot') else []:
                        if cog_name == 'PublicBank':
                            public_bank_cog = cog
                            break
                
                if public_bank_cog and hasattr(public_bank_cog, 'add_casino_loss'):
                    success = await public_bank_cog.add_casino_loss(self.bet_amount * 2, "ppc_tie")
                    if success:
                        transfer_msg = f"üèõÔ∏è **{self.bet_amount * 2:,}** PrissBucks transf√©r√©s vers la banque publique."
                    else:
                        transfer_msg = f"‚ö†Ô∏è **{self.bet_amount * 2:,}** PrissBucks perdus (erreur transfert)."
                else:
                    # Fallback vers owner
                    if OWNER_ID:
                        await self.db.update_balance(OWNER_ID, self.bet_amount * 2)
                        transfer_msg = f"üí∞ **{self.bet_amount * 2:,}** PrissBucks vers le casino."
                    else:
                        transfer_msg = f"üí∏ **{self.bet_amount * 2:,}** PrissBucks perdus."
                
                embed = discord.Embed(
                    title="ü§ù √âgalit√© !",
                    description=f"**{c_emoji} vs {o_emoji}**\n\n"
                               f"{self.challenger.display_name}: **{self.challenger_choice.capitalize()}**\n"
                               f"{self.opponent.display_name}: **{self.opponent_choice.capitalize()}**\n\n"
                               f"{transfer_msg}",
                    color=Colors.WARNING
                )
                
                # Nouveaux soldes apr√®s √©galit√©
                challenger_balance_after = challenger_balance_before - self.bet_amount
                opponent_balance_after = opponent_balance_before - self.bet_amount
                
            else:
                # VICTOIRE: Le gagnant prend tout
                loser = self.opponent if winner == self.challenger else self.challenger
                total_pot = self.bet_amount * 2
                
                logger.info(f"PPC: {winner.display_name} GAGNE - R√©cup√®re {total_pot} PB")
                
                # Syst√®me CORRECT: Le perdant donne sa mise au gagnant, le gagnant garde la sienne
                success = await self.db.transfer(loser.id, winner.id, self.bet_amount)
                
                if success:
                    transfer_msg = f"üí∞ **{winner.display_name}** remporte **{total_pot:,}** PrissBucks !"
                    
                    # Calculer les nouveaux soldes
                    if winner == self.challenger:
                        challenger_balance_after = challenger_balance_before + self.bet_amount  # Gagne la mise adverse
                        opponent_balance_after = opponent_balance_before - self.bet_amount      # Perd sa mise
                    else:
                        challenger_balance_after = challenger_balance_before - self.bet_amount  # Perd sa mise
                        opponent_balance_after = opponent_balance_before + self.bet_amount      # Gagne la mise adverse
                        
                else:
                    # Si le transfert √©choue, d√©biter quand m√™me le perdant
                    await self.db.update_balance(loser.id, -self.bet_amount)
                    transfer_msg = f"‚ö†Ô∏è **{winner.display_name}** gagne mais probl√®me de transfert."
                    
                    # Calculer les soldes en cas d'erreur
                    if winner == self.challenger:
                        challenger_balance_after = challenger_balance_before  # Pas de changement
                        opponent_balance_after = opponent_balance_before - self.bet_amount
                    else:
                        challenger_balance_after = challenger_balance_before - self.bet_amount
                        opponent_balance_after = opponent_balance_before  # Pas de changement
                
                embed = discord.Embed(
                    title=f"üèÜ {winner.display_name} gagne !",
                    description=f"**{c_emoji} vs {o_emoji}**\n\n"
                               f"{self.challenger.display_name}: **{self.challenger_choice.capitalize()}**\n"
                               f"{self.opponent.display_name}: **{self.opponent_choice.capitalize()}**\n\n"
                               f"{transfer_msg}",
                    color=Colors.SUCCESS
                )
            
            # Logger les transactions si le syst√®me de logs existe
            bot = None
            if hasattr(self.db, 'bot'):
                bot = self.db.bot
            
            if bot and hasattr(bot, 'transaction_logs'):
                try:
                    if winner == 'tie':
                        # Log √©galit√© pour les deux joueurs
                        await bot.transaction_logs.log_ppc_result(
                            self.challenger.id, self.bet_amount, 'tie', 0,
                            challenger_balance_before, challenger_balance_after,
                            self.opponent.display_name
                        )
                        await bot.transaction_logs.log_ppc_result(
                            self.opponent.id, self.bet_amount, 'tie', 0,
                            opponent_balance_before, opponent_balance_after,
                            self.challenger.display_name
                        )
                    else:
                        # Log victoire/d√©faite
                        loser = self.opponent if winner == self.challenger else self.challenger
                        
                        await bot.transaction_logs.log_ppc_result(
                            winner.id, self.bet_amount, 'win', self.bet_amount,
                            challenger_balance_before if winner == self.challenger else opponent_balance_before,
                            challenger_balance_after if winner == self.challenger else opponent_balance_after,
                            loser.display_name
                        )
                        await bot.transaction_logs.log_ppc_result(
                            loser.id, self.bet_amount, 'loss', 0,
                            opponent_balance_before if loser == self.opponent else challenger_balance_before,
                            opponent_balance_after if loser == self.opponent else challenger_balance_after,
                            winner.display_name
                        )
                except Exception as e:
                    logger.error(f"Erreur log PPC: {e}")
            
            # Ajouter les r√®gles
            embed.add_field(
                name="üéØ R√®gles",
                value="üóø Pierre bat ‚úÇÔ∏è Ciseaux\nüìÑ Papier bat üóø Pierre\n‚úÇÔ∏è Ciseaux bat üìÑ Papier",
                inline=True
            )
            
            embed.add_field(
                name="üí∞ Mise",
                value=f"{self.bet_amount:,} PrissBucks chacun",
                inline=True
            )
            
            # Nouveaux soldes
            embed.add_field(
                name="üí≥ Nouveaux soldes",
                value=f"{self.challenger.display_name}: {challenger_balance_after:,} PB\n"
                      f"{self.opponent.display_name}: {opponent_balance_after:,} PB",
                inline=False
            )
            
            # D√©sactiver tous les boutons
            for item in self.children:
                item.disabled = True
            
            # Modifier le message
            try:
                await self.message.edit(embed=embed, view=self)
            except Exception as e:
                logger.error(f"Erreur mise √† jour r√©sultat final: {e}")
                
        except Exception as e:
            logger.error(f"Erreur critique finish_game: {e}")
            # Embed d'erreur
            embed = discord.Embed(
                title="‚ùå Erreur de jeu",
                description="Une erreur s'est produite lors de la finalisation. Contactez un admin.",
                color=Colors.ERROR
            )
            for item in self.children:
                item.disabled = True
            try:
                await self.message.edit(embed=embed, view=self)
            except:
                pass

    def create_game_embed(self):
        """Cr√©e l'embed pour l'√©tat actuel du jeu"""
        embed = discord.Embed(
            title="üéÆ Pierre - Papier - Ciseaux",
            description=f"**Mode BO1** - Un seul round !\n\n"
                       f"üí∞ **Mise:** {self.bet_amount:,} PrissBucks par joueur\n"
                       f"üèÜ **Pot total:** {self.bet_amount * 2:,} PrissBucks\n"
                       f"üë• **Joueurs:** {self.challenger.display_name} vs {self.opponent.display_name}\n\n"
                       f"‚ö° **NOUVEAU SYST√àME SOLIDAIRE:**\n"
                       f"‚Ä¢ Victoire = Gagnant r√©cup√®re tout le pot\n"
                       f"‚Ä¢ √âgalit√© = Banque publique (accessible √† tous)\n"
                       f"‚Ä¢ Abandon = Banque publique",
            color=Colors.PREMIUM
        )
        
        embed.add_field(
            name="üéØ R√®gles",
            value="üóø Pierre bat ‚úÇÔ∏è Ciseaux\nüìÑ Papier bat üóø Pierre\n‚úÇÔ∏è Ciseaux bat üìÑ Papier",
            inline=True
        )
        
        embed.add_field(
            name="‚è±Ô∏è Temps limite",
            value="60 secondes pour jouer",
            inline=True
        )
        
        embed.add_field(
            name="üèõÔ∏è R√©volution Sociale",
            value="‚Ä¢ **Plus de pertes inutiles !**\n‚Ä¢ √âgalit√©s ‚Üí Banque publique\n‚Ä¢ Tout le monde peut r√©cup√©rer avec `/publicbank`",
            inline=False
        )
        
        embed.set_footer(text="Syst√®me √©quitable r√©volutionnaire ! üèõÔ∏è")
        
        return embed

    def determine_winner(self):
        """D√©termine le gagnant selon les r√®gles du PPC"""
        c_choice = self.challenger_choice
        o_choice = self.opponent_choice
        
        if c_choice == o_choice:
            return 'tie'
        
        winning_combinations = {
            ('pierre', 'ciseaux'): True,
            ('papier', 'pierre'): True,
            ('ciseaux', 'papier'): True
        }
        
        if winning_combinations.get((c_choice, o_choice), False):
            return self.challenger
        else:
            return self.opponent

    async def on_timeout(self):
        """En cas de timeout, les mises vont √† la banque publique"""
        try:
            # D√©biter les deux joueurs
            await self.db.update_balance(self.challenger.id, -self.bet_amount)
            await self.db.update_balance(self.opponent.id, -self.bet_amount)
            
            # Envoyer vers banque publique
            public_bank_cog = None
            if hasattr(self.db, 'bot'):
                public_bank_cog = self.db.bot.get_cog('PublicBank')
            
            if public_bank_cog and hasattr(public_bank_cog, 'add_casino_loss'):
                success = await public_bank_cog.add_casino_loss(self.bet_amount * 2, "ppc_timeout")
                if success:
                    timeout_msg = f"üèõÔ∏è **{self.bet_amount * 2:,}** PrissBucks transf√©r√©s vers la banque publique par abandon."
                else:
                    timeout_msg = f"üí∏ **{self.bet_amount * 2:,}** PrissBucks perdus par abandon."
            else:
                # Fallback vers owner
                if OWNER_ID:
                    await self.db.update_balance(OWNER_ID, self.bet_amount * 2)
                    timeout_msg = f"üí∞ **{self.bet_amount * 2:,}** PrissBucks vers le casino par abandon."
                else:
                    timeout_msg = f"üí∏ **{self.bet_amount * 2:,}** PrissBucks perdus par abandon."

            embed = discord.Embed(
                title="‚è∞ Temps √©coul√© !",
                description=f"Le jeu PPC a expir√©.\n\n"
                           f"**Choix faits:**\n"
                           f"{self.challenger.display_name}: {self.challenger_choice or 'Aucun'}\n"
                           f"{self.opponent.display_name}: {self.opponent_choice or 'Aucun'}\n\n"
                           f"{timeout_msg}\n"
                           f"üèõÔ∏è Utilise `/publicbank` pour r√©cup√©rer des fonds !",
                color=Colors.ERROR
            )
            
            # D√©sactiver les boutons
            for item in self.children:
                item.disabled = True
                
            try:
                await self.message.edit(embed=embed, view=self)
            except:
                pass
                
        except Exception as e:
            logger.error(f"Erreur timeout PPC: {e}")

class PierrepapierCiseaux(commands.Cog):
    """Mini-jeu Pierre-Papier-Ciseaux avec syst√®me SOLIDAIRE r√©volutionnaire"""
    
    def __init__(self, bot):
        self.bot = bot
        self.db = None
    
    async def cog_load(self):
        """Appel√© quand le cog est charg√©"""
        self.db = self.bot.database
        # Attacher le bot √† la DB pour acc√®s aux cogs
        if hasattr(self.db, 'bot'):
            pass
        else:
            self.db.bot = self.bot
        logger.info("‚úÖ Cog Pierre-Papier-Ciseaux SOLIDAIRE initialis√© avec syst√®me r√©volutionnaire")

    # ==================== PPC COMMANDS ====================

    @app_commands.command(name="ppc", description="üéÆ Pierre-Papier-Ciseaux SOLIDAIRE ! √âgalit√©s ‚Üí Banque publique !")
    @app_commands.describe(
        adversaire="L'utilisateur que tu veux d√©fier",
        mise="Montant √† miser (en PrissBucks)"
    )
    async def ppc_command(self, interaction: discord.Interaction, adversaire: discord.Member, mise: int):
        """Lance un d√©fi Pierre-Papier-Ciseaux SOLIDAIRE"""
        # R√©pondre imm√©diatement pour √©viter le timeout
        await interaction.response.defer()
        
        challenger = interaction.user
        opponent = adversaire
        bet_amount = mise
        
        # Validations de base
        if bet_amount <= 0:
            embed = create_error_embed("Mise invalide", "La mise doit √™tre positive !")
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
            
        if bet_amount > 50000:  # Limite raisonnable
            embed = create_error_embed("Mise trop √©lev√©e", "Limite: 50,000 PrissBucks par partie.")
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
            
        if challenger.id == opponent.id:
            embed = create_error_embed("D√©fi impossible", "Tu ne peux pas te d√©fier toi-m√™me !")
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
            
        if opponent.bot:
            embed = create_error_embed("D√©fi impossible", "Tu ne peux pas d√©fier un bot !")
            await interaction.followup.send(embed=embed, ephemeral=True)
            return

        try:
            # V√©rifier les soldes SANS d√©biter (le d√©bit se fera selon le r√©sultat)
            challenger_balance = await self.db.get_balance(challenger.id)
            opponent_balance = await self.db.get_balance(opponent.id)
            
            if challenger_balance < bet_amount:
                embed = create_error_embed(
                    "Solde insuffisant",
                    f"Tu as {challenger_balance:,} PrissBucks mais tu essaies de miser {bet_amount:,} PrissBucks."
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                return
                
            if opponent_balance < bet_amount:
                embed = create_error_embed(
                    "Adversaire sans fonds",
                    f"{opponent.display_name} n'a que {opponent_balance:,} PrissBucks mais la mise est de {bet_amount:,} PrissBucks."
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                return

            logger.info(f"PPC SOLIDAIRE: D√©fi lanc√© - {challenger} vs {opponent} pour {bet_amount} PB chacun")

            # Cr√©er la vue avec les boutons
            view = PPCView(challenger, opponent, bet_amount, self.db)
            
            # Cr√©er l'embed initial
            embed = view.create_game_embed()
            
            # Envoyer le message PUBLIC
            message = await interaction.followup.send(embed=embed, view=view)
            
            # Sauvegarder la r√©f√©rence du message pour les modifications
            view.message = message
            
        except Exception as e:
            logger.error(f"Erreur PPC {challenger.id} vs {opponent.id}: {e}")
            embed = create_error_embed("Erreur", "Erreur lors de la cr√©ation du jeu.")
            await interaction.followup.send(embed=embed, ephemeral=True)

    # ==================== STATS COMMANDS ====================

    @commands.command(name='ppc_stats')
    async def ppc_stats_cmd(self, ctx, user: discord.Member = None):
        """Affiche des statistiques PPC basiques"""
        target = user or ctx.author
        
        try:
            balance = await self.db.get_balance(target.id)
            embed = discord.Embed(
                title=f"üéÆ Statistiques PPC de {target.display_name}",
                description=f"**Solde actuel:** {balance:,} PrissBucks\n\n"
                           f"*üèõÔ∏è SYST√àME SOLIDAIRE R√âVOLUTIONNAIRE*\n"
                           f"‚Ä¢ √âgalit√©s alimentent la banque publique\n"
                           f"‚Ä¢ Tout le monde peut r√©cup√©rer avec `/publicbank`\n"
                           f"‚Ä¢ Plus de pertes inutiles !",
                color=Colors.INFO
            )
            embed.set_thumbnail(url=target.display_avatar.url)
            embed.add_field(
                name="üéØ Comment jouer",
                value="Utilise `/ppc @adversaire <mise>` pour d√©fier quelqu'un !",
                inline=False
            )
            embed.add_field(
                name="üèõÔ∏è R√©volution PPC",
                value="‚Ä¢ Victoire = Tu r√©cup√®res tout le pot\n"
                      "‚Ä¢ √âgalit√© = Banque publique\n"
                      "‚Ä¢ Abandon = Banque publique\n"
                      "‚Ä¢ Solidarit√© maximale !",
                inline=False
            )
            await ctx.send(embed=embed)
            
        except Exception as e:
            logger.error(f"Erreur stats PPC: {e}")
            embed = create_error_embed("Erreur", "Erreur lors de la r√©cup√©ration des statistiques.")
            await ctx.send(embed=embed)

    @app_commands.command(name="ppc_info", description="Affiche les informations sur le syst√®me PPC SOLIDAIRE")
    async def ppc_info_slash(self, interaction: discord.Interaction):
        """Slash command pour les infos PPC"""
        embed = discord.Embed(
            title="üéÆ Pierre-Papier-Ciseaux SOLIDAIRE",
            description="**R√âVOLUTION SOCIALE !** Fini les pertes inutiles !\n\n"
                       "üèõÔ∏è Syst√®me solidaire o√π les √©galit√©s alimentent une banque publique accessible √† tous !",
            color=Colors.GOLD
        )
        
        embed.add_field(
            name="üéØ R√®gles du jeu",
            value="üóø Pierre bat ‚úÇÔ∏è Ciseaux\n"
                  "üìÑ Papier bat üóø Pierre\n"
                  "‚úÇÔ∏è Ciseaux bat üìÑ Papier",
            inline=True
        )
        
        embed.add_field(
            name="üèõÔ∏è NOUVEAU: Syst√®me Solidaire",
            value="‚Ä¢ **Victoire:** Gagnant prend tout le pot\n"
                  "‚Ä¢ **√âgalit√©:** ‚Üí Banque publique\n"
                  "‚Ä¢ **Abandon:** ‚Üí Banque publique\n"
                  "‚Ä¢ **R√©cup√©ration:** `/publicbank`",
            inline=True
        )
        
        embed.add_field(
            name="‚ö° Format BO1",
            value="‚Ä¢ Un seul round par partie\n"
                  "‚Ä¢ Rapide et efficace\n"
                  "‚Ä¢ 60 secondes pour choisir\n"
                  "‚Ä¢ **Syst√®me √©quitable r√©volutionnaire**",
            inline=True
        )
        
        embed.add_field(
            name="üöÄ Comment jouer",
            value="`/ppc @adversaire <mise>` - Lance un d√©fi\n"
                  "`ppc_stats [@user]` - Voir les statistiques",
            inline=False
        )
        
        embed.add_field(
            name="üèõÔ∏è R√©volution PPC",
            value="**FINI LES PERTES DANS LE VIDE !**\n"
                  "‚Ä¢ √âgalit√©s ‚Üí Banque publique\n"
                  "‚Ä¢ Tous les joueurs peuvent r√©cup√©rer\n"
                  "‚Ä¢ Solidarit√© maximale entre joueurs\n"
                  "‚Ä¢ `/withdraw_public` pour r√©cup√©rer !",
            inline=False
        )
        
        embed.set_footer(text="Syst√®me solidaire r√©volutionnaire ! Plus personne ne perd vraiment ! üèõÔ∏è")
        await interaction.response.send_message(embed=embed)

async def setup(bot):
    """Fonction appel√©e pour charger le cog"""
    await bot.add_cog(PierrepapierCiseaux(bot))