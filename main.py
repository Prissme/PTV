import discord
from discord.ext import commands
import asyncio
import logging
import os
import signal
import sys
from pathlib import Path
from typing import Optional, List
import traceback

# Imports locaux
from config import TOKEN, PREFIX, DATABASE_URL, LOG_LEVEL, HEALTH_PORT
from database.db import Database

# Import conditionnel du serveur de sant√©
try:
    from health_server import HealthServer
    HEALTH_SERVER_AVAILABLE = True
except ImportError:
    HEALTH_SERVER_AVAILABLE = False
    logging.warning("‚ö†Ô∏è health_server.py non trouv√©, pas de health check")

# Configuration du logging optimis√©e
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL.upper()),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('bot.log', encoding='utf-8', mode='a') if os.getenv('LOG_FILE') else logging.NullHandler()
    ]
)
logger = logging.getLogger(__name__)

class EconomyBot:
    """Bot √©conomie avec architecture moderne et gestion d'erreurs robuste"""
    
    def __init__(self):
        # Configuration des intents
        intents = discord.Intents.default()
        intents.message_content = True
        intents.guilds = True
        intents.guild_messages = True
        
        # Initialisation du bot
        self.bot = commands.Bot(command_prefix=PREFIX, intents=intents, help_command=None)
        self.database: Optional[Database] = None
        self.health_server: Optional[HealthServer] = None
        
        # √âtat du bot
        self.is_ready = False
        self.shutdown_requested = False
        
        # Services
        self.services: List[asyncio.Task] = []
        
        # Configuration des √©v√©nements
        self._setup_bot_events()
        self._setup_signal_handlers()
    
    def _setup_signal_handlers(self):
        """Configure les gestionnaires de signaux pour arr√™t propre"""
        if sys.platform != "win32":
            for sig in (signal.SIGTERM, signal.SIGINT):
                signal.signal(sig, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Gestionnaire de signaux pour arr√™t gracieux"""
        logger.info(f"Signal {signum} re√ßu, arr√™t en cours...")
        self.shutdown_requested = True
    
    def _setup_bot_events(self):
        """Configure les √©v√©nements du bot"""
        
        @self.bot.event
        async def on_ready():
            """√âv√©nement d√©clench√© quand le bot est pr√™t"""
            logger.info(f"‚úÖ {self.bot.user} connect√© ! Serveurs: {len(self.bot.guilds)}")
            
            # Synchroniser les slash commands une seule fois
            try:
                synced = await self.bot.tree.sync()
                logger.info(f"üîÑ {len(synced)} slash command(s) synchronis√©e(s)")
            except Exception as e:
                logger.error(f"‚ùå Erreur sync slash commands: {e}")
            
            self.is_ready = True
        
        @self.bot.event
        async def on_guild_join(guild):
            """√âv√©nement quand le bot rejoint un serveur"""
            logger.info(f"‚úÖ Ajout√© √†: {guild.name} ({guild.id}) - {guild.member_count} membres")
        
        @self.bot.event
        async def on_guild_remove(guild):
            """√âv√©nement quand le bot quitte un serveur"""
            logger.info(f"‚ùå Retir√© de: {guild.name} ({guild.id})")
        
        @self.bot.event
        async def on_command_error(ctx, error):
            """Gestion globale des erreurs - version simplifi√©e"""
            if hasattr(ctx.command, 'has_error_handler') and ctx.command.has_error_handler():
                return
            
            error_handlers = {
                commands.CommandNotFound: None,  # Ignorer
                commands.MissingRequiredArgument: ("‚ùå **Argument manquant !**", False),
                commands.BadArgument: ("‚ùå **Argument invalide !**", False),
                commands.CommandOnCooldown: (f"‚è∞ **Cooldown !** R√©essaye dans {error.retry_after:.1f}s.", False),
                commands.MissingPermissions: ("‚ùå **Permissions insuffisantes !**", False),
                commands.BotMissingPermissions: (f"‚ùå **Bot sans permissions:** {', '.join(error.missing_permissions)}", False),
                commands.NotOwner: ("‚ùå **Commande r√©serv√©e au propri√©taire !**", False)
            }
            
            handler = error_handlers.get(type(error))
            if handler is None:
                if isinstance(error, commands.CommandNotFound):
                    return
                # Erreur non g√©r√©e
                logger.error(f"Erreur non g√©r√©e {ctx.command}: {error}")
                await ctx.send("‚ùå **Erreur inattendue.**")
            elif handler[0]:  # Si message √† envoyer
                await ctx.send(handler[0])
        
        @self.bot.event
        async def on_application_command_error(interaction: discord.Interaction, error: discord.app_commands.AppCommandError):
            """Gestion des erreurs slash commands - version simplifi√©e"""
            embed_data = {
                discord.app_commands.CommandOnCooldown: ("‚è∞ Cooldown actif", f"R√©essaye dans **{error.retry_after:.1f}s**", 0xff9900),
                discord.app_commands.MissingPermissions: ("‚ùå Permissions insuffisantes", "Tu n'as pas les permissions n√©cessaires", 0xff0000),
            }
            
            embed_info = embed_data.get(type(error), ("‚ùå Erreur", "Une erreur s'est produite", 0xff0000))
            embed = discord.Embed(title=embed_info[0], description=embed_info[1], color=embed_info[2])
            
            try:
                if interaction.response.is_done():
                    await interaction.followup.send(embed=embed, ephemeral=True)
                else:
                    await interaction.response.send_message(embed=embed, ephemeral=True)
            except Exception:
                logger.error(f"Erreur envoi message d'erreur: {error}")
    
    async def setup_database(self) -> bool:
        """Connecte la base de donn√©es de mani√®re robuste"""
        try:
            logger.info("üîå Connexion √† la base de donn√©es...")
            self.database = Database(dsn=DATABASE_URL)
            await self.database.connect()
            self.bot.database = self.database
            logger.info("‚úÖ Base de donn√©es connect√©e")
            return True
        except Exception as e:
            logger.error(f"‚ùå Erreur connexion DB: {e}")
            logger.error(traceback.format_exc())
            return False
    
    async def load_cogs(self) -> tuple[int, int]:
        """Charge tous les cogs avec gestion d'erreurs am√©lior√©e"""
        cogs_dir = Path("cogs")
        if not cogs_dir.exists():
            logger.warning("üìÅ Dossier 'cogs' manquant, cr√©ation...")
            cogs_dir.mkdir()
            return 0, 0
        
        # Ordre de chargement (cogs critiques d'abord)
        priority_cogs = ['transaction_logs', 'economy', 'message_rewards']
        
        loaded, failed = 0, 0
        
        # Charger les cogs prioritaires
        for cog_name in priority_cogs:
            success = await self._load_single_cog(cog_name)
            if success:
                loaded += 1
            else:
                failed += 1
        
        # Configurer les logs de transactions apr√®s chargement de transaction_logs
        self._setup_transaction_logs()
        
        # Charger les autres cogs
        other_cogs = [
            f.stem for f in cogs_dir.glob("*.py") 
            if f.stem not in priority_cogs and f.stem != "__init__"
        ]
        
        for cog_name in other_cogs:
            success = await self._load_single_cog(cog_name)
            if success:
                loaded += 1
            else:
                failed += 1
        
        logger.info(f"üìä Cogs: {loaded} charg√©s, {failed} √©checs")
        return loaded, failed
    
    async def _load_single_cog(self, cog_name: str) -> bool:
        """Charge un cog unique avec gestion d'erreurs"""
        try:
            await self.bot.load_extension(f'cogs.{cog_name}')
            logger.info(f"‚úÖ Cog '{cog_name}' charg√©")
            return True
        except Exception as e:
            logger.error(f"‚ùå √âchec chargement '{cog_name}': {e}")
            return False
    
    def _setup_transaction_logs(self):
        """Configure le syst√®me de logs de transactions"""
        transaction_logs_cog = self.bot.get_cog('TransactionLogs')
        if transaction_logs_cog:
            self.bot.transaction_logs = transaction_logs_cog
            logger.info("‚úÖ Logs de transactions configur√©s")
        else:
            logger.warning("‚ö†Ô∏è Cog TransactionLogs non trouv√©")
    
    async def start_health_server(self) -> Optional[asyncio.Task]:
        """D√©marre le serveur de sant√© si disponible"""
        if not HEALTH_SERVER_AVAILABLE:
            return None
        
        try:
            self.health_server = HealthServer(port=HEALTH_PORT)
            task = asyncio.create_task(self.health_server.run_forever())
            logger.info(f"üè• Serveur de sant√© d√©marr√© sur port {HEALTH_PORT}")
            return task
        except Exception as e:
            logger.error(f"‚ùå Erreur serveur de sant√©: {e}")
            return None
    
    def add_owner_commands(self):
        """Ajoute les commandes owner essentielles"""
        
        @self.bot.command(name='reload')
        @commands.is_owner()
        async def reload_cog(ctx, cog_name: str):
            """[OWNER] Recharge un cog"""
            try:
                await self.bot.reload_extension(f'cogs.{cog_name}')
                if cog_name == 'transaction_logs':
                    self._setup_transaction_logs()
                await ctx.send(f"‚úÖ **'{cog_name}' recharg√© !**")
                logger.info(f"üîÑ Cog '{cog_name}' recharg√© par {ctx.author}")
            except Exception as e:
                await ctx.send(f"‚ùå **Erreur:** {e}")
                logger.error(f"Erreur reload {cog_name}: {e}")
        
        @self.bot.command(name='sync')
        @commands.is_owner()
        async def sync_commands(ctx):
            """[OWNER] Synchronise les slash commands"""
            try:
                synced = await self.bot.tree.sync()
                await ctx.send(f"‚úÖ **{len(synced)} commande(s) synchronis√©e(s) !**")
                logger.info(f"üîÑ Sync manuelle: {len(synced)} commandes")
            except Exception as e:
                await ctx.send(f"‚ùå **Erreur sync:** {e}")
                logger.error(f"Erreur sync: {e}")
        
        @self.bot.command(name='status')
        @commands.is_owner()
        async def bot_status(ctx):
            """[OWNER] Statut du bot"""
            embed = discord.Embed(title="ü§ñ Statut Bot", color=0x0099ff)
            embed.add_field(name="üü¢ √âtat", value="En ligne", inline=True)
            embed.add_field(name="üìä Serveurs", value=len(self.bot.guilds), inline=True)
            embed.add_field(name="üîß Cogs", value=len(self.bot.extensions), inline=True)
            embed.add_field(name="üíæ DB", value="üü¢ OK" if self.database else "üî¥ KO", inline=True)
            embed.add_field(name="üè• Sant√©", value="üü¢ OK" if self.health_server else "üî¥ KO", inline=True)
            await ctx.send(embed=embed)
    
    async def cleanup(self):
        """Nettoyage complet des ressources"""
        logger.info("üßπ Nettoyage en cours...")
        
        # Arr√™ter les services
        for service in self.services:
            if not service.done():
                service.cancel()
                try:
                    await service
                except asyncio.CancelledError:
                    pass
        
        # Fermer la base de donn√©es
        if self.database:
            try:
                await self.database.close()
                logger.info("üîå Base de donn√©es ferm√©e")
            except Exception as e:
                logger.error(f"Erreur fermeture DB: {e}")
        
        # Fermer le bot
        if not self.bot.is_closed():
            try:
                await self.bot.close()
                logger.info("ü§ñ Bot ferm√©")
            except Exception as e:
                logger.error(f"Erreur fermeture bot: {e}")
        
        logger.info("‚úÖ Nettoyage termin√©")
    
    async def run(self):
        """M√©thode principale pour lancer le bot avec gestion compl√®te d'erreurs"""
        try:
            # 1. V√©rifications pr√©alables
            if not TOKEN:
                raise ValueError("‚ùå TOKEN Discord manquant dans la configuration")
            
            if not DATABASE_URL:
                raise ValueError("‚ùå URL de base de donn√©es manquante")
            
            # 2. Connexion base de donn√©es
            if not await self.setup_database():
                raise RuntimeError("üí• Impossible de se connecter √† la base de donn√©es")
            
            # 3. Chargement des cogs
            loaded, failed = await self.load_cogs()
            if loaded == 0:
                logger.warning("‚ö†Ô∏è Aucun cog charg√©, le bot pourrait ne pas fonctionner")
            
            # 4. Commandes owner
            self.add_owner_commands()
            
            # 5. Serveur de sant√© (optionnel)
            health_task = await self.start_health_server()
            if health_task:
                self.services.append(health_task)
            
            # 6. D√©marrage du bot Discord
            logger.info("üöÄ D√©marrage du bot Discord...")
            bot_task = asyncio.create_task(self.bot.start(TOKEN))
            self.services.append(bot_task)
            
            # 7. Boucle principale avec surveillance
            await self._main_loop()
            
        except KeyboardInterrupt:
            logger.info("üëã Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"üí• Erreur fatale: {e}")
            logger.error(traceback.format_exc())
            raise
        finally:
            await self.cleanup()
    
    async def _main_loop(self):
        """Boucle principale avec surveillance des services"""
        while not self.shutdown_requested:
            try:
                # V√©rifier l'√©tat des services
                done_services = [s for s in self.services if s.done()]
                
                if done_services:
                    # Un service s'est arr√™t√©
                    for service in done_services:
                        try:
                            await service  # R√©cup√©rer l'exception si elle existe
                        except Exception as e:
                            logger.error(f"Service arr√™t√© avec erreur: {e}")
                    break
                
                # Attendre un peu avant la prochaine v√©rification
                await asyncio.sleep(1)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Erreur dans la boucle principale: {e}")
                break

# Point d'entr√©e principal
async def main():
    """Point d'entr√©e principal avec configuration d'event loop optimis√©e"""
    
    # Configuration Windows si n√©cessaire
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    
    # Cr√©ation et lancement du bot
    bot = EconomyBot()
    await bot.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Au revoir !")
    except Exception as e:
        print(f"üí• Erreur critique: {e}")
        sys.exit(1)